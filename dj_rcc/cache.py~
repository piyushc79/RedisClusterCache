from django.core.cache.backends.base import BaseCache
from django.utils import six
from django.utils.encoding import force_str
import pickle
from rediscluster import StrictRedisCluster
from rediscluster.exceptions import RedisClusterException, ClusterDownException
from redis import StrictRedis
from redis.exceptions import *
import time
from rediscluster.connection import ClusterConnectionPool

DEFAULT_TIMEOUT = 0
DEFAULT_TTL = 16

class RedisClusterCache(BaseCache):
    def __init__(self, server, params):
        super(
            RedisClusterCache, self).__init__(params)

        self.startup_nodes = []
        self._clients = {}
        if isinstance(server, list):
            for server in server:
                try:
                    host = server['host']
                    port = server['port']
                    port = int(port)

                    if not isinstance(host, str) and not isinstance(host, unicode):
                        raise ValueError(
                            'Excepting host string for server location: {}.'
                            ' Got {} instead'.format(
                                server, server['host']
                            )
                        )
                    self.startup_nodes.append(server)
                except KeyError, msg:
                    raise KeyError(
                        'Missing key for server location: {}'.format(msg)
                    )
                except TypeError:
                    raise TypeError(
                        'Expecting integer for port number, got {}'.format(
                            type(server['port'])
                        )
                    )
        else:
            raise TypeError(
                'Excepting list for server location, got {}: {}'.format(
                    type(server), server
                )
            )
        self._options = params.get('OPTIONS')
        self.connection_pool = ClusterConnectionPool(
            startup_nodes=self.startup_nodes,
            max_connections=self._options['max_connections'],
        )
        self.RedisClusterRequestTTL = DEFAULT_TTL
        self.refresh_table_asap = False
        self.response_callbacks = StrictRedis.RESPONSE_CALLBACKS.copy()

    def _determine_slot(self, *args):
            
        if len(args) < 1:  #<=
            raise RedisClusterException("No way to dispatch this command to Redis Cluster. Missing key.")
        command = args[0]

        if command == 'EVAL':
            numkeys = args[2]
            keys = args[3: 3 + numkeys]
            slots = set([self.connection_pool.nodes.keyslot(key) for key in keys])
            if len(slots) != 1:
                raise RedisClusterException("EVAL - all keys must map to the same key slot")
            return slots.pop()

        key = args[1]

        return self.connection_pool.nodes.keyslot(key)

    def execute_command(self, *args, **kwargs):
        #import ipdb; ipdb.set_trace()
        if len(args) == 0:
            raise RedisClusterException("Unable to determine command to use")

        if self.refresh_table_asap:
            self.connection_pool.nodes.initialize()
            self.refresh_table_asap = False
        action = {}
        command = args[0]
        try_random_node = False
        slot = self._determine_slot(*args)
        ttl = int(self.RedisClusterRequestTTL)
        while ttl > 0:
            ttl -= 1
            if action.get("method", "") == "ask":
                node = self.connection_pool.nodes.nodes[action['name']]
                r = self.connection_pool.get_connection_by_node(node)
            elif try_random_node:
                r = self.connection_pool.get_random_connection()
                try_random_node = False
            else:
                node = self.connection_pool.get_node_by_slot(slot)
                r = self.connection_pool.get_connection_by_node(node)

            try:
                r.send_command(*args)
                return self.parse_response(r, command, **kwargs)

            except (RedisClusterException, BusyLoadingError):
                raise
            except (ConnectionError, TimeoutError):
                try_random_node = True
                if ttl < self.RedisClusterRequestTTL / 2:
                    time.sleep(0.1)
            finally:
                self.connection_pool.release(r)
        raise RedisClusterException("Too many Cluster redirections")

    def parse_response(self, connection, command_name, **options):
        response = connection.read_response()
        if command_name in self.response_callbacks:
            return self.response_callbacks[command_name](response, **options)
        return response

    def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):

        if not isinstance(key, str) and not isinstance(key, unicode):
            raise TypeError(
                'Expecting str for key, got {} instead: {}'.format(
                    type(key), key
                )
            )
        self.set(key, value, timeout)

        if value == self.get(key):
            return True
        return False

    def get(self, key):#, default=None, version=None):
        if not isinstance(key, str) and not isinstance(key, unicode):
            raise TypeError(
                'Expecting str for key, got {} instead: {}'.format(
                    type(key), key
                )
            )
        #import ipdb; ipdb.set_trace()
        value = self.execute_command(*('get', key,))  #self._client.get(key)

        if value:
            value = pickle.loads(value)

        return value

    def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):
        value = pickle.dumps(value)
       # import ipdb; ipdb.set_trace()
        self.execute_command(*('set', key, value,))

    def delete(self, key, version=None):
        self.execute_command(*('delete', key,)) #self._client.delete(key)
